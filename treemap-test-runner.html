<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Treemap Acceptance Test Runner</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body { background: #111; color: #ccc; font-family: monospace; padding: 20px; font-size: 13px; }
    .pass { color: #4ade80; } .fail { color: #f87171; } .skip { color: #fbbf24; }
    h2 { color: #fff; margin-top: 20px; border-bottom: 1px solid #333; padding-bottom: 4px; }
    .summary { margin-top: 20px; padding: 12px; border-radius: 8px; font-size: 15px; font-weight: bold; }
    .summary.all-pass { background: rgba(74,222,128,0.15); color: #4ade80; }
    .summary.has-fail { background: rgba(248,113,113,0.15); color: #f87171; }
    pre { margin: 2px 0; }
  </style>
</head>
<body>
<h1>07-Adaptive-Scaling Acceptance Test</h1>
<div id="output"></div>
<div id="test-container" style="position:absolute;left:-9999px;"></div>

<script>
// ═══ Inline all the treemap logic (same as treemap-preview.html) ═══
const sectors = [
  { code:'801080', name:'电子',     capitalFlow:145.8, change: 3.24, attention:89 },
  { code:'801790', name:'银行',     capitalFlow:125.6, change: 1.45, attention:71 },
  { code:'801150', name:'医药生物', capitalFlow: 95.2, change: 2.87, attention:81 },
  { code:'801890', name:'非银金融', capitalFlow: 89.3, change: 2.01, attention:69 },
  { code:'801120', name:'食品饮料', capitalFlow: 78.6, change: 2.56, attention:72 },
  { code:'801760', name:'计算机',   capitalFlow: 67.5, change: 2.98, attention:76 },
  { code:'801880', name:'汽车',     capitalFlow: 56.8, change: 2.43, attention:66 },
  { code:'801730', name:'电气设备', capitalFlow: 52.3, change: 2.34, attention:64 },
  { code:'801780', name:'通信',     capitalFlow: 41.2, change: 1.89, attention:61 },
  { code:'801750', name:'国防军工', capitalFlow: 34.7, change: 2.12, attention:59 },
  { code:'801110', name:'家用电器', capitalFlow: 32.4, change: 1.98, attention:51 },
  { code:'801740', name:'机械设备', capitalFlow: 28.9, change: 1.76, attention:52 },
  { code:'801030', name:'化工',     capitalFlow: 25.7, change: 2.15, attention:58 },
  { code:'801210', name:'休闲服务', capitalFlow: 22.3, change: 1.54, attention:49 },
  { code:'801050', name:'有色金属', capitalFlow: 18.9, change: 1.67, attention:55 },
  { code:'801140', name:'轻工制造', capitalFlow: 15.3, change: 0.89, attention:44 },
  { code:'801200', name:'商贸零售', capitalFlow: 12.8, change: 0.76, attention:42 },
  { code:'801010', name:'农林牧渔', capitalFlow: 12.5, change: 1.23, attention:45 },
  { code:'801160', name:'公用事业', capitalFlow:  8.7, change: 0.45, attention:36 },
  { code:'801720', name:'建筑装饰', capitalFlow:  7.2, change: 0.68, attention:40 },
  { code:'801230', name:'综合',     capitalFlow:  6.5, change: 0.32, attention:35 },
  { code:'801020', name:'采掘',     capitalFlow: -8.3, change:-0.87, attention:62 },
  { code:'801710', name:'建筑材料', capitalFlow: -9.8, change:-0.95, attention:43 },
  { code:'801130', name:'纺织服装', capitalFlow:-12.5, change:-1.12, attention:38 },
  { code:'801040', name:'钢铁',     capitalFlow:-15.2, change:-1.45, attention:41 },
  { code:'801170', name:'交通运输', capitalFlow:-18.9, change:-1.34, attention:47 },
  { code:'801770', name:'传媒',     capitalFlow:-23.4, change:-1.87, attention:54 },
  { code:'802040', name:'石油石化', capitalFlow:-27.5, change:-1.76, attention:53 },
  { code:'801950', name:'煤炭',     capitalFlow:-32.7, change:-2.15, attention:57 },
  { code:'801180', name:'房地产',   capitalFlow:-45.6, change:-2.67, attention:68 },
  { code:'801980', name:'美容护理', capitalFlow: -5.2, change:-0.38, attention:33 },
];

function getSizeCat(w, h) {
  const m = Math.min(w, h);
  if (m >= 200) return 'large'; if (m >= 120) return 'medium'; if (m >= 60) return 'small'; return 'tiny';
}

function buildSplitLines(tiles) {
  const TOL = 2.5;
  const vEdges = new Set(), hEdges = new Set();
  tiles.forEach(t => { vEdges.add(t.x0); vEdges.add(t.x1); hEdges.add(t.y0); hEdges.add(t.y1); });
  function groupEdges(edgeSet) {
    const sorted = [...edgeSet].sort((a,b) => a-b);
    const groups = []; let cur = [sorted[0]];
    for (let i = 1; i < sorted.length; i++) {
      if (sorted[i] - sorted[i-1] <= TOL) cur.push(sorted[i]);
      else { groups.push(cur); cur = [sorted[i]]; }
    }
    groups.push(cur);
    return groups.map(g => ({ canonical: Math.round(g[Math.floor(g.length/2)]), values: g }));
  }
  const vGroups = groupEdges(vEdges), hGroups = groupEdges(hEdges);
  const vMap = new Map(), hMap = new Map();
  vGroups.forEach(g => g.values.forEach(v => vMap.set(v, g.canonical)));
  hGroups.forEach(g => g.values.forEach(v => hMap.set(v, g.canonical)));
  return {
    vMap, hMap,
    vCanonicals: [...new Set(vGroups.map(g=>g.canonical))].sort((a,b)=>a-b),
    hCanonicals: [...new Set(hGroups.map(g=>g.canonical))].sort((a,b)=>a-b),
  };
}

function mapTilesToCanonical(tiles, vMap, hMap) {
  return tiles.map((t, i) => ({
    idx: i, data: t.data,
    origX0: t.x0, origY0: t.y0, origX1: t.x1, origY1: t.y1,
    cL: vMap.get(t.x0), cR: vMap.get(t.x1), cT: hMap.get(t.y0), cB: hMap.get(t.y1),
  }));
}

function analyzeCapacity(tiles, dim, lo, hi) {
  const MIN = 30; let totalOrig = 0, totalMin = 0;
  tiles.forEach(t => {
    const tLo = dim==='h' ? t.cL : t.cT, tHi = dim==='h' ? t.cR : t.cB;
    if (tHi <= lo || tLo >= hi) return;
    const origSpan = dim==='h' ? (t.origX1-t.origX0) : (t.origY1-t.origY0);
    totalOrig += origSpan; totalMin += Math.min(MIN, origSpan);
  });
  return Math.max(0, totalOrig - totalMin);
}

function computeRippleLayout(originalTiles, hovIdx, W, H) {
  const targetW = W/4, targetH = H/4;
  const { vMap, hMap, vCanonicals, hCanonicals } = buildSplitLines(originalTiles);
  const cTiles = mapTilesToCanonical(originalTiles, vMap, hMap);
  const hov = cTiles[hovIdx];
  const vLinePos = new Map(); vCanonicals.forEach(c => vLinePos.set(c, c));
  const hLinePos = new Map(); hCanonicals.forEach(c => hLinePos.set(c, c));
  const needW = Math.max(0, targetW - (hov.origX1-hov.origX0));
  const needH = Math.max(0, targetH - (hov.origY1-hov.origY0));
  if (needW <= 0 && needH <= 0) return null;

  function expandAxis(canonicals, linePos, hovLo, hovHi, need, cTiles, dim) {
    if (need <= 0) return;
    const idx0 = canonicals.indexOf(hovLo), idx1 = canonicals.indexOf(hovHi);
    const pinnedStart = (idx0 <= 1), pinnedEnd = (idx1 >= canonicals.length - 2);
    let expBefore, expAfter;
    if (pinnedStart)    { expBefore = 0;    expAfter = need; }
    else if (pinnedEnd) { expBefore = need;  expAfter = 0;   }
    else {
      const capB = analyzeCapacity(cTiles, dim, canonicals[0], hovLo);
      const capA = analyzeCapacity(cTiles, dim, hovHi, canonicals[canonicals.length-1]);
      const tot = capB + capA || 1;
      expBefore = need * (capB / tot); expAfter = need * (capA / tot);
    }
    const beforeLines = canonicals.filter(c => c > canonicals[0] && c < hovLo);
    const afterLines  = canonicals.filter(c => c > hovHi && c < canonicals[canonicals.length-1]);
    if (expBefore > 0 && beforeLines.length > 0) {
      const rS = linePos.get(canonicals[0]), rE = linePos.get(hovLo);
      const oL = rE-rS, nL = oL-expBefore;
      if (nL > 0 && oL > 0) { const r = nL/oL; beforeLines.forEach(c => linePos.set(c, rS + (linePos.get(c)-rS)*r)); }
    }
    if (expAfter > 0 && afterLines.length > 0) {
      const rS = linePos.get(hovHi), rE = linePos.get(canonicals[canonicals.length-1]);
      const oL = rE-rS, nL = oL-expAfter;
      if (nL > 0 && oL > 0) {
        const r = nL/oL, updates = [];
        afterLines.forEach(c => updates.push([c, rS + expAfter + (linePos.get(c)-rS)*r]));
        updates.forEach(([k,v]) => linePos.set(k,v));
      }
      linePos.set(hovHi, linePos.get(hovHi) + expAfter);
    }
    if (expBefore > 0) linePos.set(hovLo, linePos.get(hovLo) - expBefore);
  }

  expandAxis(vCanonicals, vLinePos, hov.cL, hov.cR, needW, cTiles, 'h');
  expandAxis(hCanonicals, hLinePos, hov.cT, hov.cB, needH, cTiles, 'v');

  return cTiles.map(t => {
    const x0 = vLinePos.get(t.cL), x1 = vLinePos.get(t.cR);
    const y0 = hLinePos.get(t.cT), y1 = hLinePos.get(t.cB);
    return { x: x0, y: y0, w: Math.max(4, x1-x0), h: Math.max(4, y1-y0), data: t.data, idx: t.idx };
  });
}

// ═══ Test Runner ═══
const out = document.getElementById('output');
const SIZES = { xl:{w:1200,h:1140}, l:{w:800,h:760}, m:{w:600,h:570} };
let totalPass = 0, totalFail = 0, totalSkip = 0;

function log(msg, cls='') { out.innerHTML += `<pre class="${cls}">${msg}</pre>`; }

function computeLayoutForSize(W, H) {
  const root = d3.hierarchy({ children: sectors })
    .sum(d => Math.pow(Math.abs(d.capitalFlow||0), 0.8))
    .sort((a,b) => (b.value||0) - (a.value||0));
  // Stretch virtual height to bias tiles toward horizontal (wider than tall)
  const S = 1.35;
  d3.treemap().size([W, H*S]).padding(2).tile(d3.treemapSquarify.ratio(1))(root);
  // No tile size clamping — W/4×H/4 is hover expansion target, not initial layout constraint
  return root.leaves().map(n => {
    return { x0:n.x0, y0:n.y0/S, x1:n.x1, y1:n.y1/S, data:n.data };
  });
}

function checkOverlaps(layout, tolerance) {
  let overlaps = 0;
  for (let i = 0; i < layout.length; i++) {
    for (let j = i+1; j < layout.length; j++) {
      const a = layout[i], b = layout[j];
      const ox = Math.max(0, Math.min(a.x+a.w, b.x+b.w) - Math.max(a.x, b.x));
      const oy = Math.max(0, Math.min(a.y+a.h, b.y+b.h) - Math.max(a.y, b.y));
      if (ox > tolerance && oy > tolerance) overlaps++;
    }
  }
  return overlaps;
}

function checkOverflow(layout, W, H) {
  for (const t of layout) {
    if (t.x < -1 || t.y < -1 || t.x + t.w > W+1 || t.y + t.h > H+1) return true;
  }
  return false;
}

// ═══ TEST 1: Content Adaptive Scaling ═══
log('\n═══════════════════════════════════════');
log('TEST 1: Content Adaptive Scaling');
log('═══════════════════════════════════════');

for (const [sizeKey, sz] of Object.entries(SIZES)) {
  log(`\n── ${sizeKey.toUpperCase()} (${sz.w}×${sz.h}) ──`);
  const leaves = computeLayoutForSize(sz.w, sz.h);
  let cats = { large:0, medium:0, small:0, tiny:0 };
  leaves.forEach(l => { cats[getSizeCat(l.x1-l.x0, l.y1-l.y0)]++; });
  log(`  Large:${cats.large} Medium:${cats.medium} Small:${cats.small} Tiny:${cats.tiny}`);

  // Check: all tiles categorized correctly
  let catOk = true;
  leaves.forEach(l => {
    const w = l.x1-l.x0, h = l.y1-l.y0, m = Math.min(w,h);
    const cat = getSizeCat(w,h);
    if (m >= 200 && cat !== 'large') catOk = false;
    if (m >= 120 && m < 200 && cat !== 'medium') catOk = false;
    if (m >= 60 && m < 120 && cat !== 'small') catOk = false;
    if (m < 60 && cat !== 'tiny') catOk = false;
  });
  if (catOk) { log(`  ✓ Size categorization correct`, 'pass'); totalPass++; }
  else { log(`  ✗ Size categorization WRONG`, 'fail'); totalFail++; }

  // Horizontal rate
  let horiz = 0;
  leaves.forEach(l => { if (l.x1-l.x0 >= l.y1-l.y0) horiz++; });
  const horizRate = Math.round(horiz/leaves.length*100);
  if (horizRate >= 80) { log(`  ✓ Horizontal rate: ${horizRate}% (≥80%)`, 'pass'); totalPass++; }
  else { log(`  ✗ Horizontal rate: ${horizRate}% (<80%)`, 'fail'); totalFail++; }
}

// ═══ TEST 2: Water Ripple Expansion ═══
log('\n\n═══════════════════════════════════════');
log('TEST 2: Water Ripple Expansion (all small tiles × 3 sizes)');
log('═══════════════════════════════════════');

for (const [sizeKey, sz] of Object.entries(SIZES)) {
  const W = sz.w, H = sz.h;
  const targetW = W/4, targetH = H/4;
  log(`\n── ${sizeKey.toUpperCase()} (${W}×${H}) target: ${targetW.toFixed(0)}×${targetH.toFixed(0)} ──`);

  const leaves = computeLayoutForSize(W, H);
  const smallTiles = leaves.map((l,i) => ({i, name:l.data.name, minDim:Math.min(l.x1-l.x0, l.y1-l.y0)}))
    .filter(t => t.minDim < 200);

  log(`  Testing ${smallTiles.length} small tiles...`);

  let sizePass=0, sizeFail=0, overlapFail=0, overflowFail=0, skipped=0;

  for (const tile of smallTiles) {
    const ripple = computeRippleLayout(leaves, tile.i, W, H);
    if (!ripple) { skipped++; totalSkip++; continue; }

    const hov = ripple[tile.i];
    const rW = hov.w/targetW, rH = hov.h/targetH;
    const passSize = rW >= 0.95 && rH >= 0.95;
    const overlaps = checkOverlaps(ripple, 2.5);
    const overflow = checkOverflow(ripple, W, H);

    if (passSize) sizePass++; else sizeFail++;
    if (overlaps > 0) overlapFail++;
    if (overflow) overflowFail++;

    if (!passSize || overlaps > 0 || overflow) {
      log(`  ✗ ${tile.name} [${tile.i}]: ${hov.w.toFixed(0)}×${hov.h.toFixed(0)} (${(rW*100).toFixed(1)}%×${(rH*100).toFixed(1)}%) overlaps:${overlaps} overflow:${overflow}`, 'fail');
    }
  }

  const tested = smallTiles.length - skipped;
  log(`  Size ≥95%: ${sizePass}/${tested} ${sizeFail > 0 ? 'FAIL' : 'PASS'}`, sizeFail > 0 ? 'fail' : 'pass');
  log(`  Zero overlaps: ${tested - overlapFail}/${tested} ${overlapFail > 0 ? 'FAIL' : 'PASS'}`, overlapFail > 0 ? 'fail' : 'pass');
  log(`  No overflow: ${tested - overflowFail}/${tested} ${overflowFail > 0 ? 'FAIL' : 'PASS'}`, overflowFail > 0 ? 'fail' : 'pass');

  totalPass += (sizeFail === 0 ? 1 : 0) + (overlapFail === 0 ? 1 : 0) + (overflowFail === 0 ? 1 : 0);
  totalFail += (sizeFail > 0 ? 1 : 0) + (overlapFail > 0 ? 1 : 0) + (overflowFail > 0 ? 1 : 0);
}

// TEST 3 removed: W/4×H/4 is the hover expansion target, not an initial layout constraint.
// Large tiles simply don't trigger hover expansion (per coldstart design).

// ═══ TEST 3: 7-Stop Color Ramp ═══
log('\n\n═══════════════════════════════════════');
log('TEST 3: 7-Stop Color Ramp (Binance-style)');
log('═══════════════════════════════════════');

function get7StopColor(ch) {
  if (ch <= -5)   return '#0B8C5F';  // deep green
  if (ch <= -2)   return '#2EBD85';  // medium green
  if (ch <= -0.5) return '#58CEAA';  // light green
  if (ch < 0.5)   return '#76808E';  // gray (neutral)
  if (ch < 2)     return '#E8626F';  // light red
  if (ch < 5)     return '#F6465D';  // medium red
  return '#CF304A';                   // deep red
}

let colorOk = true;
const colorTests = [
  { ch: -6.0, expected: '#0B8C5F', label: 'deep green (<-5%)' },
  { ch: -3.0, expected: '#2EBD85', label: 'medium green (-2~-5%)' },
  { ch: -1.0, expected: '#58CEAA', label: 'light green (-0.5~-2%)' },
  { ch:  0.1, expected: '#76808E', label: 'gray (±0.5%)' },
  { ch: -0.2, expected: '#76808E', label: 'gray negative (±0.5%)' },
  { ch:  1.0, expected: '#E8626F', label: 'light red (+0.5~+2%)' },
  { ch:  3.5, expected: '#F6465D', label: 'medium red (+2~+5%)' },
  { ch:  6.0, expected: '#CF304A', label: 'deep red (>+5%)' },
];

for (const test of colorTests) {
  const got = get7StopColor(test.ch);
  if (got !== test.expected) {
    log(`  ✗ ${test.label}: expected ${test.expected}, got ${got}`, 'fail');
    colorOk = false;
  }
}

if (colorOk) { log(`  ✓ 7-stop color ramp mapping correct (${colorTests.length} cases)`, 'pass'); totalPass++; }
else { log(`  ✗ 7-stop color ramp mapping incorrect`, 'fail'); totalFail++; }

// ═══ TEST 4: No Non-Padding Gaps ═══
log('\n\n═══════════════════════════════════════');
log('TEST 4: No Non-Padding Gaps Between Tiles');
log('═══════════════════════════════════════');

for (const [sizeKey, sz] of Object.entries(SIZES)) {
  const W = sz.w, H = sz.h;
  const leaves = computeLayoutForSize(W, H);
  const PAD_TOL = 4; // padding(2) + tolerance

  // For each tile, check if space around it is accounted for by neighbors or container edge
  let maxGap = 0;
  let gapDetails = '';

  for (let i = 0; i < leaves.length; i++) {
    const a = leaves[i];
    const aW = a.x1 - a.x0, aH = a.y1 - a.y0;
    const aX = a.x0, aY = a.y0;

    // Check right side: find nearest neighbor to the right that overlaps vertically
    if (a.x1 < W - PAD_TOL) {
      let minRightGap = Infinity;
      for (let j = 0; j < leaves.length; j++) {
        if (i === j) continue;
        const b = leaves[j];
        // Must overlap vertically
        const vOverlap = Math.min(a.y1, b.y1) - Math.max(a.y0, b.y0);
        if (vOverlap <= 0) continue;
        // Must be to the right
        if (b.x0 >= a.x1 - PAD_TOL) {
          minRightGap = Math.min(minRightGap, b.x0 - a.x1);
        }
      }
      if (minRightGap !== Infinity && minRightGap > PAD_TOL) {
        maxGap = Math.max(maxGap, minRightGap);
        gapDetails = `${a.data.name} right gap: ${minRightGap.toFixed(1)}px`;
      }
    }

    // Check bottom side
    if (a.y1 < H - PAD_TOL) {
      let minBottomGap = Infinity;
      for (let j = 0; j < leaves.length; j++) {
        if (i === j) continue;
        const b = leaves[j];
        const hOverlap = Math.min(a.x1, b.x1) - Math.max(a.x0, b.x0);
        if (hOverlap <= 0) continue;
        if (b.y0 >= a.y1 - PAD_TOL) {
          minBottomGap = Math.min(minBottomGap, b.y0 - a.y1);
        }
      }
      if (minBottomGap !== Infinity && minBottomGap > PAD_TOL) {
        maxGap = Math.max(maxGap, minBottomGap);
        gapDetails = `${a.data.name} bottom gap: ${minBottomGap.toFixed(1)}px`;
      }
    }
  }

  if (maxGap <= PAD_TOL) {
    log(`  ✓ ${sizeKey.toUpperCase()}: No gaps (max: ${maxGap.toFixed(1)}px ≤ ${PAD_TOL}px tolerance)`, 'pass');
    totalPass++;
  } else {
    log(`  ✗ ${sizeKey.toUpperCase()}: Gap detected — ${gapDetails}`, 'fail');
    totalFail++;
  }
}

// ═══ TEST 5: Sparkline Data & Path Generation ═══
log('\n\n═══════════════════════════════════════');
log('TEST 5: Sparkline Data & Path Generation');
log('═══════════════════════════════════════');

// Inline candlestick functions (same as treemap-preview.html)
function generateMockCandles(changePercent, days) {
  if (typeof days === 'undefined') days = 60;
  const basePrice = 50 + Math.random() * 150;
  const dailyDrift = changePercent / days / 100;
  const volatility = 0.015 + Math.random() * 0.01;
  const candles = [];
  let price = basePrice;
  for (let i = 0; i < days; i++) {
    const open = price;
    const noise = (Math.random() - 0.5) * 2;
    const dailyReturn = dailyDrift + volatility * noise;
    price = open * (1 + dailyReturn);
    candles.push({ open, close: price });
  }
  const target = basePrice * (1 + changePercent / 100);
  candles[days - 1].close += (target - candles[days - 1].close) * 0.5;
  return candles;
}

function computeCandleBars(candles, width, height) {
  if (candles.length < 2) return [];
  let lo = Infinity, hi = -Infinity;
  for (const c of candles) {
    lo = Math.min(lo, c.open, c.close);
    hi = Math.max(hi, c.open, c.close);
  }
  const range = hi - lo || 1;
  const padY = height * 0.08;
  const drawH = height - 2 * padY;
  function priceToY(p) { return padY + drawH - ((p - lo) / range) * drawH; }
  const n = candles.length;
  const barW = width / n;
  const gap = barW * 0.15;
  const bodyW = barW - gap;
  return candles.map((c, i) => {
    const yOpen = priceToY(c.open);
    const yClose = priceToY(c.close);
    const yTop = Math.min(yOpen, yClose);
    const barH = Math.max(1, Math.abs(yClose - yOpen));
    const x = i * barW + gap / 2;
    const isUp = c.close >= c.open;
    return { x, y: yTop, w: bodyW, h: barH, isUp };
  });
}

// 5a: generateMockCandles produces correct length & valid open/close pairs
{
  let ok = true;
  for (const cp of [-3.5, 0, 2.1, 5.0]) {
    const candles = generateMockCandles(cp, 60);
    if (candles.length !== 60) { ok = false; log(`  ✗ Candle count: expected 60, got ${candles.length} (cp=${cp})`, 'fail'); }
    for (let i = 0; i < candles.length; i++) {
      const c = candles[i];
      if (!isFinite(c.open) || !isFinite(c.close) || c.open <= 0 || c.close <= 0) {
        ok = false; log(`  ✗ Invalid candle at index ${i} (cp=${cp}): open=${c.open}, close=${c.close}`, 'fail'); break;
      }
    }
  }
  if (ok) { log(`  ✓ generateMockCandles: correct count (60) & all positive finite values`, 'pass'); totalPass++; }
  else totalFail++;
}

// 5b: Candles are continuous (open[i] = close[i-1])
{
  let ok = true;
  for (let trial = 0; trial < 10; trial++) {
    const candles = generateMockCandles(2.0, 60);
    for (let i = 1; i < candles.length; i++) {
      if (Math.abs(candles[i].open - candles[i-1].close) > 0.001) {
        ok = false;
        log(`  ✗ Continuity break at index ${i}: open=${candles[i].open.toFixed(4)}, prev close=${candles[i-1].close.toFixed(4)}`, 'fail');
        break;
      }
    }
    if (!ok) break;
  }
  if (ok) { log(`  ✓ Candles are continuous: open[i] ≈ close[i-1] for all i`, 'pass'); totalPass++; }
  else totalFail++;
}

// 5c: Overall trend direction matches changePercent sign
{
  let ok = true;
  const trials = 20;
  for (const cp of [3.0, -3.0]) {
    let matchCount = 0;
    for (let t = 0; t < trials; t++) {
      const candles = generateMockCandles(cp, 60);
      const trendUp = candles[candles.length - 1].close > candles[0].open;
      if ((cp > 0 && trendUp) || (cp < 0 && !trendUp)) matchCount++;
    }
    if (matchCount < trials * 0.7) {
      ok = false;
      log(`  ✗ Trend direction (cp=${cp}): only ${matchCount}/${trials} matched`, 'fail');
    }
  }
  if (ok) { log(`  ✓ Candle trend direction matches changePercent sign (≥70% of ${trials} trials)`, 'pass'); totalPass++; }
  else totalFail++;
}

// 5d: computeCandleBars Y values stay within padded bounds & bars fill width
{
  let ok = true;
  const W = 200, H = 80;
  const padY = H * 0.08;
  for (let trial = 0; trial < 10; trial++) {
    const candles = generateMockCandles(2.0, 60);
    const bars = computeCandleBars(candles, W, H);
    if (bars.length !== 60) { ok = false; log(`  ✗ Expected 60 bars, got ${bars.length}`, 'fail'); break; }
    for (const b of bars) {
      if (b.y < padY - 0.5 || b.y + b.h > H - padY + 0.5) {
        ok = false;
        log(`  ✗ Bar Y out of bounds: y=${b.y.toFixed(2)}, h=${b.h.toFixed(2)}, bounds=[${padY.toFixed(2)}, ${(H-padY).toFixed(2)}]`, 'fail');
        break;
      }
    }
    // First bar starts near 0, last bar ends near W
    const firstBarX = bars[0].x;
    const lastBarEnd = bars[bars.length - 1].x + bars[bars.length - 1].w;
    if (firstBarX > W * 0.05) { ok = false; log(`  ✗ First bar starts too far right: ${firstBarX.toFixed(1)}`, 'fail'); }
    if (lastBarEnd < W * 0.95) { ok = false; log(`  ✗ Last bar ends too early: ${lastBarEnd.toFixed(1)} < ${(W*0.95).toFixed(1)}`, 'fail'); }
    if (!ok) break;
  }
  if (ok) { log(`  ✓ computeCandleBars: all bars within [8%, 92%] Y bounds, fill width`, 'pass'); totalPass++; }
  else totalFail++;
}

// 5e: Bar properties — up/down opacity, no overlapping bars, positive dimensions
{
  let ok = true;
  const candles = generateMockCandles(1.5, 60);
  const bars = computeCandleBars(candles, 200, 80);
  // Check all bars have positive dimensions
  for (let i = 0; i < bars.length; i++) {
    const b = bars[i];
    if (b.w <= 0 || b.h <= 0) { ok = false; log(`  ✗ Bar ${i} has non-positive dimension: w=${b.w}, h=${b.h}`, 'fail'); }
    if (typeof b.isUp !== 'boolean') { ok = false; log(`  ✗ Bar ${i} missing isUp flag`, 'fail'); }
  }
  // Check no horizontal overlap between adjacent bars
  for (let i = 0; i < bars.length - 1; i++) {
    const rightEdge = bars[i].x + bars[i].w;
    const nextLeft = bars[i + 1].x;
    if (rightEdge > nextLeft + 0.5) {
      ok = false;
      log(`  ✗ Bars ${i} and ${i+1} overlap: rightEdge=${rightEdge.toFixed(1)} > nextLeft=${nextLeft.toFixed(1)}`, 'fail');
    }
  }
  // Check isUp matches candle data
  for (let i = 0; i < candles.length; i++) {
    const expected = candles[i].close >= candles[i].open;
    if (bars[i].isUp !== expected) {
      ok = false; log(`  ✗ Bar ${i} isUp=${bars[i].isUp} but expected ${expected}`, 'fail');
    }
  }
  if (ok) { log(`  ✓ Bar properties: positive dims, no overlap, correct up/down flags`, 'pass'); totalPass++; }
  else totalFail++;
}

// ═══ TEST 6: Tile Flex Layout — Badge & Sparkline Non-Overlap ═══
log('\n\n═══════════════════════════════════════');
log('TEST 6: Tile Flex Layout — Badge & Sparkline Non-Overlap');
log('═══════════════════════════════════════');

// Simulate the flex column layout logic:
// tile-content { flex-direction: column; height: tileH; padding: pad }
// ├── tile-header  { flex-shrink: 0; height: headerH }
// ├── tile-sparkline { flex: 1; margin: 4px 0; display: block|none }
// └── tile-badge   { flex-shrink: 0; margin-top: auto; align-self: flex-end }
//
// Key invariant: badge must always be at the bottom, sparkline must not overlap badge.

{
  let ok = true;

  // Helper: compute layout positions for the flex children
  function computeFlexLayout(tileH, pad, headerH, badgeH, sparklineVisible) {
    const contentH = tileH - 2 * pad;
    const headerTop = 0;
    const headerBottom = headerH;
    let badgeTop, badgeBottom, sparkTop, sparkBottom;

    if (sparklineVisible) {
      // flex:1 sparkline takes remaining space between header and badge
      const sparkMargin = 4; // 4px top and bottom margin
      sparkTop = headerBottom + sparkMargin;
      badgeBottom = contentH;
      badgeTop = badgeBottom - badgeH;
      sparkBottom = badgeTop - sparkMargin;
    } else {
      // sparkline hidden, badge pushed to bottom by margin-top:auto
      sparkTop = sparkBottom = headerBottom; // zero-height
      badgeBottom = contentH;
      badgeTop = badgeBottom - badgeH;
    }

    return { headerTop, headerBottom, sparkTop, sparkBottom, badgeTop, badgeBottom, contentH };
  }

  // 6a: Badge at bottom in non-hovered state (sparkline hidden)
  const noSparkline = computeFlexLayout(300, 16, 20, 24, false);
  const badgeBottomMargin = noSparkline.contentH - noSparkline.badgeBottom;
  if (badgeBottomMargin > 1) {
    ok = false;
    log(`  ✗ Badge not at bottom when sparkline hidden: gap=${badgeBottomMargin.toFixed(1)}px`, 'fail');
  }

  // 6b: Badge at bottom in hovered state (sparkline visible)
  const withSparkline = computeFlexLayout(300, 16, 20, 24, true);
  const badgeBottomMargin2 = withSparkline.contentH - withSparkline.badgeBottom;
  if (badgeBottomMargin2 > 1) {
    ok = false;
    log(`  ✗ Badge not at bottom when sparkline visible: gap=${badgeBottomMargin2.toFixed(1)}px`, 'fail');
  }

  // 6c: Sparkline does not overlap badge
  if (withSparkline.sparkBottom > withSparkline.badgeTop + 0.5) {
    ok = false;
    log(`  ✗ Sparkline overlaps badge: sparkBottom=${withSparkline.sparkBottom.toFixed(1)} > badgeTop=${withSparkline.badgeTop.toFixed(1)}`, 'fail');
  }

  // 6d: Sparkline does not overlap header
  if (withSparkline.sparkTop < withSparkline.headerBottom - 0.5) {
    ok = false;
    log(`  ✗ Sparkline overlaps header: sparkTop=${withSparkline.sparkTop.toFixed(1)} < headerBottom=${withSparkline.headerBottom.toFixed(1)}`, 'fail');
  }

  // 6e: Sparkline has breathing room (≥4px margin from header and badge)
  const breathingTop = withSparkline.sparkTop - withSparkline.headerBottom;
  const breathingBottom = withSparkline.badgeTop - withSparkline.sparkBottom;
  if (breathingTop < 3.5 || breathingBottom < 3.5) {
    ok = false;
    log(`  ✗ Insufficient breathing room: top=${breathingTop.toFixed(1)}px bottom=${breathingBottom.toFixed(1)}px (need ≥4px)`, 'fail');
  }

  // 6f: Various tile sizes — badge always at bottom, no overlap
  for (const tileH of [120, 200, 300, 400]) {
    for (const vis of [true, false]) {
      const layout = computeFlexLayout(tileH, Math.min(16, tileH * 0.05), 18, 22, vis);
      if (layout.badgeBottom > layout.contentH + 0.5) {
        ok = false;
        log(`  ✗ Badge overflow at tileH=${tileH}, sparkline=${vis}`, 'fail');
      }
      if (vis && layout.sparkBottom > layout.badgeTop + 0.5) {
        ok = false;
        log(`  ✗ Overlap at tileH=${tileH}`, 'fail');
      }
    }
  }

  if (ok) {
    log(`  ✓ Badge always at bottom-right, sparkline in bounded middle frame, no overlap`, 'pass');
    totalPass++;
  } else {
    totalFail++;
  }
}

// ═══ SUMMARY ═══
log('\n\n═══════════════════════════════════════');
const allPassed = totalFail === 0;
const summaryEl = document.createElement('div');
summaryEl.className = `summary ${allPassed ? 'all-pass' : 'has-fail'}`;
summaryEl.textContent = `${allPassed ? '✓ ALL TESTS PASSED' : '✗ SOME TESTS FAILED'} — Pass: ${totalPass}  Fail: ${totalFail}  Skip: ${totalSkip}`;
out.appendChild(summaryEl);

// Output JSON for programmatic consumption
window.__testResults = { pass: totalPass, fail: totalFail, skip: totalSkip, allPassed };
</script>
</body>
</html>
